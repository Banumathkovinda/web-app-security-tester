"""
Vulnerability Scanner Module
Detects common web vulnerabilities using requests library.
"""

import requests
import re
import urllib.parse
from typing import Dict, List, Any, Optional
from bs4 import BeautifulSoup


class VulnerabilityScanner:
    """Scanner for common web application vulnerabilities."""
    
    def __init__(self):
        self.session = requests.Session()
        self.session.verify = False
        self.session.headers.update({
            'User-Agent': 'WebSecTester/1.0 Security Scanner'
        })
        
        # Common payloads for testing
        self.xss_payloads = [
            '<script>alert(1)</script>',
            '<img src=x onerror=alert(1)>',
            'javascript:alert(1)',
            '"><script>alert(1)</script>',
            "'><script>alert(1)</script>",
            '<svg onload=alert(1)>',
            'alert(1)',
            '"-alert(1)-"',
            "'-alert(1)-'"
        ]
        
        self.sqli_payloads = [
            "'",
            "''",
            "' OR '1'='1",
            "' OR 1=1--",
            "' AND 1=1--",
            "1' ORDER BY 1--",
            "1' UNION SELECT null--",
            "' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
            "1 AND 1=1",
            "1 AND 1=2",
            "1' AND 1=1--",
            "1' AND 1=2--"
        ]
        
        self.error_patterns = [
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_.*",
            r"valid MySQL result",
            r"PostgreSQL.*Error",
            r"Warning.*pg_.*",
            r"valid PostgreSQL result",
            r"ORA-[0-9]{5}",
            r"Microsoft SQL Server.*Error",
            r"ODBC SQL Server Driver",
            r"SQLServer JDBC Driver",
            r"SqlException",
            r"sqlite3.*OperationalError",
            r"SQLite/JDBCDriver",
            r"SQLiteException",
            r"System.Data.SQLite.SQLiteException"
        ]
    
    def scan(self, target_url: str, proxies: Optional[Dict] = None) -> List[Dict]:
        """
        Perform vulnerability scan on target URL.
        
        Args:
            target_url: URL to scan
            proxies: Optional proxy configuration
            
        Returns:
            List of vulnerability findings
        """
        findings = []
        
        try:
            # Get initial response and parse forms
            response = self.session.get(target_url, proxies=proxies, timeout=30)
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Test for XSS vulnerabilities
            xss_results = self._test_xss(target_url, soup, proxies)
            findings.extend(xss_results)
            
            # Test for SQL injection
            sqli_results = self._test_sql_injection(target_url, soup, proxies)
            findings.extend(sqli_results)
            
            # Test for other vulnerabilities
            other_results = self._test_other_vulnerabilities(target_url, soup, proxies)
            findings.extend(other_results)
            
        except requests.exceptions.RequestException as e:
            findings.append({
                'type': 'error',
                'severity': 'info',
                'title': 'Scan Error',
                'description': f'Error during vulnerability scan: {str(e)}',
                'details': {}
            })
        
        return findings
    
    def _test_xss(self, target_url: str, soup: BeautifulSoup, proxies: Optional[Dict]) -> List[Dict]:
        """Test for XSS vulnerabilities in forms and URL parameters."""
        findings = []
        
        # Test URL parameters
        parsed_url = urllib.parse.urlparse(target_url)
        params = urllib.parse.parse_qs(parsed_url.query)
        
        if params:
            base_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
            for param_name in params.keys():
                for payload in self.xss_payloads[:3]:  # Test first 3 payloads
                    test_params = params.copy()
                    test_params[param_name] = payload
                    test_url = f"{base_url}?{urllib.parse.urlencode(test_params, doseq=True)}"
                    
                    try:
                        response = self.session.get(test_url, proxies=proxies, timeout=10)
                        
                        # Check if payload is reflected
                        if payload in response.text:
                            findings.append({
                                'type': 'xss',
                                'severity': 'high',
                                'title': 'Reflected XSS Vulnerability',
                                'description': f'Potential XSS vulnerability found in parameter "{param_name}"',
                                'details': {
                                    'parameter': param_name,
                                    'payload': payload,
                                    'url': test_url,
                                    'evidence': 'Payload was reflected in response'
                                },
                                'remediation': 'Implement proper input validation and output encoding. Use Content Security Policy (CSP).'
                            })
                            break  # Found vulnerability, move to next parameter
                            
                    except requests.exceptions.RequestException:
                        continue
        
        # Test forms
        forms = soup.find_all('form')
        for form in forms:
            action = form.get('action', '')
            method = form.get('method', 'get').lower()
            form_url = urllib.parse.urljoin(target_url, action)
            
            inputs = form.find_all(['input', 'textarea'])
            for input_field in inputs:
                input_name = input_field.get('name')
                if not input_name:
                    continue
                
                for payload in self.xss_payloads[:2]:
                    data = {input_name: payload}
                    
                    try:
                        if method == 'post':
                            response = self.session.post(form_url, data=data, proxies=proxies, timeout=10)
                        else:
                            response = self.session.get(form_url, params=data, proxies=proxies, timeout=10)
                        
                        if payload in response.text:
                            findings.append({
                                'type': 'xss',
                                'severity': 'high',
                                'title': 'Stored/DOM XSS Vulnerability',
                                'description': f'Potential XSS vulnerability found in form field "{input_name}"',
                                'details': {
                                    'form_action': form_url,
                                    'field': input_name,
                                    'payload': payload,
                                    'method': method
                                },
                                'remediation': 'Implement proper input validation and output encoding. Sanitize all user input.'
                            })
                            break
                            
                    except requests.exceptions.RequestException:
                        continue
        
        return findings
    
    def _test_sql_injection(self, target_url: str, soup: BeautifulSoup, proxies: Optional[Dict]) -> List[Dict]:
        """Test for SQL injection vulnerabilities."""
        findings = []
        
        parsed_url = urllib.parse.urlparse(target_url)
        params = urllib.parse.parse_qs(parsed_url.query)
        
        if not params:
            # Try to add a test parameter
            params = {'id': ['1']}
        
        base_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
        
        for param_name in params.keys():
            for payload in self.sqli_payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                test_url = f"{base_url}?{urllib.parse.urlencode(test_params, doseq=True)}"
                
                try:
                    response = self.session.get(test_url, proxies=proxies, timeout=15)
                    
                    # Check for SQL error messages
                    for pattern in self.error_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            findings.append({
                                'type': 'sql_injection',
                                'severity': 'critical',
                                'title': 'SQL Injection Vulnerability',
                                'description': f'Potential SQL injection found in parameter "{param_name}"',
                                'details': {
                                    'parameter': param_name,
                                    'payload': payload,
                                    'url': test_url,
                                    'evidence': f'Database error pattern detected: {pattern}'
                                },
                                'remediation': 'Use parameterized queries/prepared statements. Implement proper input validation.'
                            })
                            return findings  # Stop after finding SQLi
                    
                    # Check for time-based blind SQLi
                    if 'SLEEP' in payload or 'sleep' in payload:
                        if response.elapsed.total_seconds() > 4:
                            findings.append({
                                'type': 'sql_injection',
                                'severity': 'critical',
                                'title': 'Blind SQL Injection (Time-Based)',
                                'description': f'Time-based SQL injection detected in parameter "{param_name}"',
                                'details': {
                                    'parameter': param_name,
                                    'payload': payload,
                                    'response_time': response.elapsed.total_seconds(),
                                    'url': test_url
                                },
                                'remediation': 'Use parameterized queries/prepared statements. Avoid dynamic SQL.'
                            })
                            return findings
                            
                except requests.exceptions.RequestException:
                    continue
        
        return findings
    
    def _test_other_vulnerabilities(self, target_url: str, soup: BeautifulSoup, 
                                    proxies: Optional[Dict]) -> List[Dict]:
        """Test for other common vulnerabilities."""
        findings = []
        
        # Check for open redirects
        parsed_url = urllib.parse.urlparse(target_url)
        params = urllib.parse.parse_qs(parsed_url.query)
        
        redirect_params = ['url', 'redirect', 'return', 'return_url', 'next', 'goto', 'redir']
        for param_name in params.keys():
            if any(rp in param_name.lower() for rp in redirect_params):
                test_url = target_url.replace(
                    f"{param_name}={urllib.parse.quote(params[param_name][0])}",
                    f"{param_name}=https://evil.com"
                )
                
                try:
                    response = self.session.get(test_url, proxies=proxies, timeout=10, allow_redirects=False)
                    
                    if response.status_code in [301, 302, 303, 307, 308]:
                        location = response.headers.get('Location', '')
                        if 'evil.com' in location:
                            findings.append({
                                'type': 'open_redirect',
                                'severity': 'medium',
                                'title': 'Open Redirect Vulnerability',
                                'description': f'Potential open redirect found in parameter "{param_name}"',
                                'details': {
                                    'parameter': param_name,
                                    'payload': 'https://evil.com',
                                    'redirect_location': location
                                },
                                'remediation': 'Validate and whitelist redirect URLs. Do not use user input for redirects.'
                            })
                except requests.exceptions.RequestException:
                    pass
        
        # Check for CSRF protection
        forms = soup.find_all('form')
        for form in forms:
            csrf_tokens = form.find_all(['input'], {'name': re.compile(r'csrf|token|authenticity', re.I)})
            if not csrf_tokens:
                method = form.get('method', 'get').lower()
                if method == 'post':
                    action = form.get('action', '')
                    findings.append({
                        'type': 'csrf',
                        'severity': 'medium',
                        'title': 'Missing CSRF Protection',
                        'description': f'Form may lack CSRF protection: {action}',
                        'details': {
                            'form_action': action,
                            'form_method': method
                        },
                        'remediation': 'Implement CSRF tokens for all state-changing operations.'
                    })
        
        # Check for information disclosure in comments
        comments = soup.find_all(string=lambda text: isinstance(text, str) and '<!--' in text)
        for comment in comments:
            sensitive_patterns = ['password', 'secret', 'key', 'admin', 'internal', 'todo', 'fixme', 'hack']
            lower_comment = comment.lower()
            for pattern in sensitive_patterns:
                if pattern in lower_comment:
                    findings.append({
                        'type': 'info_disclosure',
                        'severity': 'low',
                        'title': 'Sensitive Information in HTML Comment',
                        'description': f'Potential sensitive information found in HTML comment',
                        'details': {
                            'keyword': pattern,
                            'context': comment[:200]
                        },
                        'remediation': 'Remove sensitive information from HTML comments before deployment.'
                    })
                    break
        
        return findings
